{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction \u00b6 Extensible Virtual Display Interface (EVDI in short) is a software project that allows any userspace Linux program manage additional displays, and receive updates for them. This short document explains how to use EVDI library in your application. For more details about EVDI project and the latest code, see the project page on DisplayLink's GitHub. Project origin \u00b6 EVDI is a project that was started by DisplayLink as a base for the development of DisplayLink's Display driver for Ubuntu Linux, driving all current generation, USB 3.0 Universal Docking Stations and USB Display Adapters. However, it soon became apparent that we're making a generic interface that any other application could use - and that's when DisplayLink decided to open-source the code and push it to GitHub. Info The interface of the library is still changing. Please treat the API as not yet stable - in terms of allowing the possibility that it can still be modified, and your clients may require matching updates.","title":"Home"},{"location":"#introduction","text":"Extensible Virtual Display Interface (EVDI in short) is a software project that allows any userspace Linux program manage additional displays, and receive updates for them. This short document explains how to use EVDI library in your application. For more details about EVDI project and the latest code, see the project page on DisplayLink's GitHub.","title":"Introduction"},{"location":"#project-origin","text":"EVDI is a project that was started by DisplayLink as a base for the development of DisplayLink's Display driver for Ubuntu Linux, driving all current generation, USB 3.0 Universal Docking Stations and USB Display Adapters. However, it soon became apparent that we're making a generic interface that any other application could use - and that's when DisplayLink decided to open-source the code and push it to GitHub. Info The interface of the library is still changing. Please treat the API as not yet stable - in terms of allowing the possibility that it can still be modified, and your clients may require matching updates.","title":"Project origin"},{"location":"details/","text":"API Details Functions by group Versioning Module parameters EVDI nodes Finding an available EVDI node to use Adding new EVDI node (pre v1.9.0) Opening device nodes (pre v1.9.0) Request evdi nodes (since v1.9.0) Closing devices Connection Opening connections Disconnecting Buffers Registering Unregistering Screen updates Requesting an update Grabbing pixels DDC/CI response Events and handlers DPMS mode change Mode change notification Update ready notification Cursor change notification Cursor move notification CRTC state change DDC/CI data notification Logging Types evdi_handle evdi_selectable evdi_device_status evdi_rect evdi_mode evdi_buffer evdi_event_context evdi_lib_version evdi_cursor_set evdi_cursor_move evdi_ddcci_data evdi_logging API Details \u00b6 Functions by group \u00b6 Versioning \u00b6 1 evdi_get_lib_version ( struct evdi_lib_version device ); Function returns library version. It uses semantic versioning to mark compatibility changes. Version consists of 3 components formatted as MAJOR.MINOR.PATCH MAJOR number is changed for incompatibile API changes MINOR number is changed for backwards-compatible changes PATCH number is changed for backwards-compatibile bug fixes Module parameters \u00b6 User can modify driver behaviour by its parameters that can be set at module load time or changed during runtime. initial_device_count Number of evdi devices added at module load time (default: 0) EVDI nodes \u00b6 Finding an available EVDI node to use \u00b6 1 evdi_device_status evdi_check_device ( int device ); Use this function to check if a particular /dev/dri/cardX is EVDI or not. Arguments: device is a number of card to check, e.g. passing 1 will mean /dev/dri/card1 . Return value: AVAILABLE if the device node is EVDI and is available to use. UNRECOGNIZED when a node has not been created by EVDI kernel module. NOT_PRESENT in other cases, e.g. when the device does not exist or cannot be opened to check. Adding new EVDI node (pre v1.9.0) \u00b6 1 int evdi_add_device () Use this to tell the kernel module to create a new cardX node for your application to use. Return value: 1 when successful, 0 otherwise. Opening device nodes (pre v1.9.0) \u00b6 1 evdi_handle evdi_open ( int device ); This function attempts to open a DRM device node with given number as EVDI. Function performs compatibility check with underlying drm device. If version of the library and module does not match then the device will not be opened. Arguments : device is a number of card to open, e.g. 1 means /dev/dri/card1 . Return value: On success, a handle to the opened device to be used in following API calls. EVDI_INVALID_HANDLE otherwise. Request evdi nodes (since v1.9.0) \u00b6 1 evdi_handle evdi_open_attached_to ( char * sysfs_parent_device ); This function attempts to add (if necessary) and open a DRM device node attached to given parent device. Linking with another sysfs device is sometimes useful if it is required to reflect such relationship in sysfs. The function performs a compatibility check with an underlying drm device. If version of the library and module does not match, the device will not be opened. Arguments : sysfs_parent_device is a string with the following format: usb:[busNum]-[portNum1].[portNum2].[portNum3]... , which describes the device that evdi is linked to. Or NULL when evdi device node is not linked with any other device. Return value: On success, a handle to the opened device to be used in following API calls. EVDI_INVALID_HANDLE otherwise. Closing devices \u00b6 1 void evdi_close ( evdi_handle handle ); Closes an opened EVDI handle. Arguments : handle to an opened device that is to be closed. Connection \u00b6 Opening connections \u00b6 1 2 3 4 void evdi_connect ( evdi_handle handle , const unsigned char * edid , const unsigned edid_length , const uint32_t sku_area_limit ); Creates a connection between the EVDI and Linux DRM subsystem, resulting in kernel mode driver processing a hot plug event. Arguments : handle to an opened device edid should be a pointer to a memory block with contents of an EDID of a monitor that will be exposed to kernel edid_length is the length of the EDID block (typically 512 bytes, or more if extension blocks are present) sku_area_limit is maximum pixel area (width x height) connected device can display Disconnecting \u00b6 1 void evdi_disconnect ( evdi_handle handle ) Breaks the connection between the device handle and DRM subsystem - resulting in an unplug event being processed. Arguments : handle to an opened device. Buffers \u00b6 Managing memory for frame buffers is left to the client applications. The evdi_buffer structure is used to let the library know details about the frame buffer your application is working with. For more details, see struct evdi_buffer description. Registering \u00b6 1 void evdi_register_buffer ( evdi_handle handle , evdi_buffer buffer ); This function allows to register a buffer of type evdi_buffer with an opened EVDI device handle . Warning Registering a buffer does not allocate memory for the frame. Unregistering \u00b6 1 void evdi_unregister_buffer ( evdi_handle handle , int bufferId ); This function unregisters a buffer with a given bufferId from an opened EVDI device handle . Warning Unregistering a buffer does not deallocate memory for the frame. Screen updates \u00b6 Requesting an update \u00b6 1 bool evdi_request_update ( evdi_handle handle , int bufferId ); Requests an update for a buffer with a given bufferId . The buffer must be already registered with the library. Arguments : handle to an opened device. bufferId is an identifier for a buffer that should be updated. Return value: The function can return true if the data for the buffer is ready to be grabbed immediately after the call. If false is returned, then an update is not yet ready to grab and the application should wait until it gets notified by the kernel module - see Events and handlers . Grabbing pixels \u00b6 1 void evdi_grab_pixels ( evdi_handle handle , evdi_rect * rects , int * num_rects ); Grabs pixels following the most recent update request (see Requesting an update ). This should be called either after a call to evdi_request_update (if it returns true which means pixels can be grabbed immediately), or while handling the update_ready notification. Arguments : handle to an opened device. rects is a pointer to the first evdi_rect that the library fills, based on what the kernel tells. Note It is expected that this pointer is a beginning of an array of evdi_rect s, and current implementation assumes the array does not contain more than 16 slots for rects. num_rects is a pointer to an integer that will be modified to tell how many dirty rectangles are valid in the list, and the client should only care about as many. In particular, a failed grab will be indicated by 0 valid rectangles to take into account (this can happen when there was a mode change between the request and the grab). DDC/CI response \u00b6 1 2 void evdi_ddcci_response ( evdi_handle handle , const unsigned char * buffer , const uint32_t buffer_length , const bool result ); Pass back DDC/CI data following the most recent DDC/CI request to the EVDI kernel driver (see DDC/CI data notification ). Arguments : handle to an opened device. buffer a pointer to the response buffer. This will be copied into kernel space. buffer_length the length of the response buffer. result the boolean result. The caller should set result to true if the most recent DDC/CI request was successful and false if it was unsuccessful. If false, buffer and buffer_length are ignored. Note The buffer_length will be truncated to 64 bytes ( DDCCI_BUFFER_SIZE ). Events and handlers \u00b6 DPMS mode change \u00b6 1 void ( * dpms_handler )( int dpms_mode , void * user_data ); This notification is sent when a DPMS mode changes. The possible modes are as defined by the standard, and values are bit-compatible with DRM interface: /* DPMS flags */ # define DRM_MODE_DPMS_ON 0 # define DRM_MODE_DPMS_STANDBY 1 # define DRM_MODE_DPMS_SUSPEND 2 # define DRM_MODE_DPMS_OFF 3 Mode change notification \u00b6 1 void ( * mode_changed_handler )( evdi_mode mode , void * user_data ); This notification is sent when a display mode changes. Details of the new mode are sent in the mode argument. See evdi_mode for description of the structure. Update ready notification \u00b6 1 void ( * update_ready_handler )( int buffer_to_be_updated , void * user_data ); This notification is sent when an update for a buffer, that had been earlier requested is ready to be consumed. The buffer number to be updated is buffer_to_be_updated . Cursor change notification \u00b6 1 void ( * cursor_set_handler )( struct evdi_cursor_set cursor_set , void * user_data ); This notification is sent for an update of cursor buffer or shape. It is also raised when cursor is enabled or disabled. Such situation happens when cursor is moved on and off the screen respectively. Cursor move notification \u00b6 1 void ( * cursor_move_handler )( struct evdi_cursor_move cursor_move , void * user_data ); This notification is sent for a cursor position change. It is raised only when cursor is positioned on virtual screen. CRTC state change \u00b6 1 void ( * crtc_state_handler )( int state , void * user_data ); Sent when DRM's CRTC changes state. The state is a value that's forwarded from the kernel. DDC/CI data notification \u00b6 1 void ( * ddcci_data_handler )( struct evdi_ddcci_data ddcci_data , void * user_data ); This notification is sent when an i2c request has been made to the DDC/CI address (0x37). The module will wait for a maximum of DDCCI_TIMEOUT_MS (50ms - The default DDC request timeout) for a response to this request to be passed back via evdi_ddcci_response . Logging \u00b6 Client can register their own callback to be used for logging instead of default printf . 1 void evdi_set_logging ( struct evdi_logging evdi_logging ); For more on argument see struct evdi_logging . Types \u00b6 evdi_handle \u00b6 This is a handle to an opened device node that you get from an evdi_open call, and use in all following API calls to indicate which EVDI device you communicate with. evdi_selectable \u00b6 A typedef denoting a file descriptor you can watch to know when there are events being signalled from the kernel module. Each opened EVDI device handle has its own descriptor to watch. When the descriptor becomes ready to read from, the application should call evdi_handle_events to dispatch notifications to its handlers. evdi_device_status \u00b6 An enumerated type used while finding the DRM device node that is EVDI. Possible values are AVAILABLE , UNRECOGNIZED and NOT_PRESENT . evdi_rect \u00b6 A simple structure used by the library to represent a rectangular area of a screen. Top left coordinates of the rectangle are x1 and y1 , bottom right are x2 and y2 . evdi_mode \u00b6 A structure used to describe a video mode that's set for a display. Contains details of resolution set ( width , height ), refresh rate ( refresh_rate ), and details of a pixel format used to encode color value ( bits_per_pixel and pixel_format - which are forwarded from kernel's DRM). evdi_buffer \u00b6 A structure holding details about a buffer. 1 2 3 4 5 6 7 8 9 10 typedef struct { int id ; void * buffer ; int width ; int height ; int stride ; evdi_rect * rects ; int rect_count ; } evdi_buffer ; Buffers have IDs, which can be arbitrarily chosen integer numbers - but typically a simple sequence of numbers starting from 0 is used in client applications. The pointer to the beginning of an already allocated memory block should be assigned to the buffer member of the structure. This memory will be filled by the kernel module when handling requests to grab pixels. width , height and stride are properties of the buffer - the first two indicate what the size of the frame is, and stride is a width stride - tells what is the increment in bytes between data for lines in memory. Stride can be equal to width of a single line multiplied by the number of bytes necessary for encoding color value for one pixel (e.g. 4 for RGB32) if the data for lines are contigous in the memory, but you can use larger value to indicate extra space/padding between them, e.g. oftentimes an additional requirement for the value of stride is it being divisbile by 8; note that those values might be specific to particular hardware/graphic drivers. Please consult documentation of your GPU for details. Last two structure members, rects and rect_counts are updated during grabbing pixels to inform about the number and coordinates of areas that are changed from the last update. evdi_event_context \u00b6 1 2 3 4 5 6 7 8 9 10 typedef struct { void ( * dpms_handler )( int dpms_mode , void * user_data ); void ( * mode_changed_handler )( evdi_mode mode , void * user_data ); void ( * update_ready_handler )( int buffer_to_be_updated , void * user_data ); void ( * crtc_state_handler )( int state , void * user_data ); void ( * cursor_set_handler )( struct evdi_cursor_set cursor_set , void * user_data ); void ( * cursor_move_handler )( struct evdi_cursor_move cursor_move , void * user_data ); void ( * ddcci_data_handler )( struct evdi_ddcci_data ddcci_data , void * user_data ); void * user_data ; } evdi_event_context ; The evdi_device_context structure is used for holding pointers to handlers for all notifications that the application may receive from the kernel module. The user_data member is a value that the library will use while dispatching the call back. See Events and handlers for more information. evdi_lib_version \u00b6 1 2 3 4 5 struct evdi_lib_version { int version_major ; int version_minor ; int version_patchlevel ; }; The evdi_lib_version structure contains libevdi version. Version can be used to check compatibility between library and a client application. evdi_cursor_set \u00b6 1 2 3 4 5 6 7 8 9 10 11 struct evdi_cursor_set { int32_t hot_x ; int32_t hot_y ; uint32_t width ; uint32_t height ; uint8_t enabled ; uint32_t buffer_length ; uint32_t * buffer ; uint32_t pixel_format ; uint32_t stride ; }; The evdi_cursor_set structure contains cursor state information. hot_x and hot_y define hotspot information. enabled parameter is true when cursor bitmap is available and cursor is visible on virtual display. Parameters width and height define size of the cursor bitmap stored in a buffer memory area of size buffer_length . Warning Event handler or library user has to free buffer memory when it is not using it. Remaining stride and pixel_format describe data organization in the buffer. stride is a size of a single line in a buffer. Usually it is width of the cursor multiplied by bytes per pixel value plus additional extra padding. It ensures proper alignment of subsequent pixel rows. Pixel encoding is described by FourCC code in pixel_format field. evdi_cursor_move \u00b6 1 2 3 4 struct evdi_cursor_move { int32_t x ; int32_t y ; }; The evdi_cursor_move structure contains current cursor position. It is defined as top left corner of the cursor bitmap. evdi_ddcci_data \u00b6 1 2 3 4 5 6 struct evdi_ddcci_data { uint16_t address ; uint16_t flags ; uint32_t buffer_length ; uint8_t * buffer ; }; The evdi_ddcci_data structure contains: address i2c address, will always be 0x37. flags read/write flags. Read = 1, Write = 0. buffer_length the length of the buffer. buffer pointer to the ddc/ci buffer. For both read and write this will be truncated to 64 bytes ( DDCCI_BUFFER_SIZE ). Warning Although the DDC spec advices the maximum buffer length is 32 bytes, we have identified monitors which support bigger buffers. evdi_logging \u00b6 1 2 3 4 struct evdi_logging { void ( * function )( void * user_data , const char * fmt , ...); void * user_data ; }; Structure contains two fields: function which is a pointer to the actual callback. The fmt and ... are the same as in case of printf . user_data a pointer provided by the client when registering callback Note By setting function to NULL libevdi will switch to default behaviour of using printf .","title":"Detailed description"},{"location":"details/#api-details","text":"","title":"API Details"},{"location":"details/#functions-by-group","text":"","title":"Functions by group"},{"location":"details/#versioning","text":"1 evdi_get_lib_version ( struct evdi_lib_version device ); Function returns library version. It uses semantic versioning to mark compatibility changes. Version consists of 3 components formatted as MAJOR.MINOR.PATCH MAJOR number is changed for incompatibile API changes MINOR number is changed for backwards-compatible changes PATCH number is changed for backwards-compatibile bug fixes","title":"Versioning"},{"location":"details/#module-parameters","text":"User can modify driver behaviour by its parameters that can be set at module load time or changed during runtime. initial_device_count Number of evdi devices added at module load time (default: 0)","title":"Module parameters"},{"location":"details/#evdi-nodes","text":"","title":"EVDI nodes"},{"location":"details/#finding-an-available-evdi-node-to-use","text":"1 evdi_device_status evdi_check_device ( int device ); Use this function to check if a particular /dev/dri/cardX is EVDI or not. Arguments: device is a number of card to check, e.g. passing 1 will mean /dev/dri/card1 . Return value: AVAILABLE if the device node is EVDI and is available to use. UNRECOGNIZED when a node has not been created by EVDI kernel module. NOT_PRESENT in other cases, e.g. when the device does not exist or cannot be opened to check.","title":"Finding an available EVDI node to use"},{"location":"details/#adding-new-evdi-node-pre-v190","text":"1 int evdi_add_device () Use this to tell the kernel module to create a new cardX node for your application to use. Return value: 1 when successful, 0 otherwise.","title":"Adding new EVDI node (pre v1.9.0)"},{"location":"details/#opening-device-nodes-pre-v190","text":"1 evdi_handle evdi_open ( int device ); This function attempts to open a DRM device node with given number as EVDI. Function performs compatibility check with underlying drm device. If version of the library and module does not match then the device will not be opened. Arguments : device is a number of card to open, e.g. 1 means /dev/dri/card1 . Return value: On success, a handle to the opened device to be used in following API calls. EVDI_INVALID_HANDLE otherwise.","title":"Opening device nodes (pre v1.9.0)"},{"location":"details/#request-evdi-nodes-since-v190","text":"1 evdi_handle evdi_open_attached_to ( char * sysfs_parent_device ); This function attempts to add (if necessary) and open a DRM device node attached to given parent device. Linking with another sysfs device is sometimes useful if it is required to reflect such relationship in sysfs. The function performs a compatibility check with an underlying drm device. If version of the library and module does not match, the device will not be opened. Arguments : sysfs_parent_device is a string with the following format: usb:[busNum]-[portNum1].[portNum2].[portNum3]... , which describes the device that evdi is linked to. Or NULL when evdi device node is not linked with any other device. Return value: On success, a handle to the opened device to be used in following API calls. EVDI_INVALID_HANDLE otherwise.","title":"Request evdi nodes (since v1.9.0)"},{"location":"details/#closing-devices","text":"1 void evdi_close ( evdi_handle handle ); Closes an opened EVDI handle. Arguments : handle to an opened device that is to be closed.","title":"Closing devices"},{"location":"details/#connection","text":"","title":"Connection"},{"location":"details/#opening-connections","text":"1 2 3 4 void evdi_connect ( evdi_handle handle , const unsigned char * edid , const unsigned edid_length , const uint32_t sku_area_limit ); Creates a connection between the EVDI and Linux DRM subsystem, resulting in kernel mode driver processing a hot plug event. Arguments : handle to an opened device edid should be a pointer to a memory block with contents of an EDID of a monitor that will be exposed to kernel edid_length is the length of the EDID block (typically 512 bytes, or more if extension blocks are present) sku_area_limit is maximum pixel area (width x height) connected device can display","title":"Opening connections"},{"location":"details/#disconnecting","text":"1 void evdi_disconnect ( evdi_handle handle ) Breaks the connection between the device handle and DRM subsystem - resulting in an unplug event being processed. Arguments : handle to an opened device.","title":"Disconnecting"},{"location":"details/#buffers","text":"Managing memory for frame buffers is left to the client applications. The evdi_buffer structure is used to let the library know details about the frame buffer your application is working with. For more details, see struct evdi_buffer description.","title":"Buffers"},{"location":"details/#registering","text":"1 void evdi_register_buffer ( evdi_handle handle , evdi_buffer buffer ); This function allows to register a buffer of type evdi_buffer with an opened EVDI device handle . Warning Registering a buffer does not allocate memory for the frame.","title":"Registering"},{"location":"details/#unregistering","text":"1 void evdi_unregister_buffer ( evdi_handle handle , int bufferId ); This function unregisters a buffer with a given bufferId from an opened EVDI device handle . Warning Unregistering a buffer does not deallocate memory for the frame.","title":"Unregistering"},{"location":"details/#screen-updates","text":"","title":"Screen updates"},{"location":"details/#requesting-an-update","text":"1 bool evdi_request_update ( evdi_handle handle , int bufferId ); Requests an update for a buffer with a given bufferId . The buffer must be already registered with the library. Arguments : handle to an opened device. bufferId is an identifier for a buffer that should be updated. Return value: The function can return true if the data for the buffer is ready to be grabbed immediately after the call. If false is returned, then an update is not yet ready to grab and the application should wait until it gets notified by the kernel module - see Events and handlers .","title":"Requesting an update"},{"location":"details/#grabbing-pixels","text":"1 void evdi_grab_pixels ( evdi_handle handle , evdi_rect * rects , int * num_rects ); Grabs pixels following the most recent update request (see Requesting an update ). This should be called either after a call to evdi_request_update (if it returns true which means pixels can be grabbed immediately), or while handling the update_ready notification. Arguments : handle to an opened device. rects is a pointer to the first evdi_rect that the library fills, based on what the kernel tells. Note It is expected that this pointer is a beginning of an array of evdi_rect s, and current implementation assumes the array does not contain more than 16 slots for rects. num_rects is a pointer to an integer that will be modified to tell how many dirty rectangles are valid in the list, and the client should only care about as many. In particular, a failed grab will be indicated by 0 valid rectangles to take into account (this can happen when there was a mode change between the request and the grab).","title":"Grabbing pixels"},{"location":"details/#ddcci-response","text":"1 2 void evdi_ddcci_response ( evdi_handle handle , const unsigned char * buffer , const uint32_t buffer_length , const bool result ); Pass back DDC/CI data following the most recent DDC/CI request to the EVDI kernel driver (see DDC/CI data notification ). Arguments : handle to an opened device. buffer a pointer to the response buffer. This will be copied into kernel space. buffer_length the length of the response buffer. result the boolean result. The caller should set result to true if the most recent DDC/CI request was successful and false if it was unsuccessful. If false, buffer and buffer_length are ignored. Note The buffer_length will be truncated to 64 bytes ( DDCCI_BUFFER_SIZE ).","title":"DDC/CI response"},{"location":"details/#events-and-handlers","text":"","title":"Events and handlers"},{"location":"details/#dpms-mode-change","text":"1 void ( * dpms_handler )( int dpms_mode , void * user_data ); This notification is sent when a DPMS mode changes. The possible modes are as defined by the standard, and values are bit-compatible with DRM interface: /* DPMS flags */ # define DRM_MODE_DPMS_ON 0 # define DRM_MODE_DPMS_STANDBY 1 # define DRM_MODE_DPMS_SUSPEND 2 # define DRM_MODE_DPMS_OFF 3","title":"DPMS mode change"},{"location":"details/#mode-change-notification","text":"1 void ( * mode_changed_handler )( evdi_mode mode , void * user_data ); This notification is sent when a display mode changes. Details of the new mode are sent in the mode argument. See evdi_mode for description of the structure.","title":"Mode change notification"},{"location":"details/#update-ready-notification","text":"1 void ( * update_ready_handler )( int buffer_to_be_updated , void * user_data ); This notification is sent when an update for a buffer, that had been earlier requested is ready to be consumed. The buffer number to be updated is buffer_to_be_updated .","title":"Update ready notification"},{"location":"details/#cursor-change-notification","text":"1 void ( * cursor_set_handler )( struct evdi_cursor_set cursor_set , void * user_data ); This notification is sent for an update of cursor buffer or shape. It is also raised when cursor is enabled or disabled. Such situation happens when cursor is moved on and off the screen respectively.","title":"Cursor change notification"},{"location":"details/#cursor-move-notification","text":"1 void ( * cursor_move_handler )( struct evdi_cursor_move cursor_move , void * user_data ); This notification is sent for a cursor position change. It is raised only when cursor is positioned on virtual screen.","title":"Cursor move notification"},{"location":"details/#crtc-state-change","text":"1 void ( * crtc_state_handler )( int state , void * user_data ); Sent when DRM's CRTC changes state. The state is a value that's forwarded from the kernel.","title":"CRTC state change"},{"location":"details/#ddcci-data-notification","text":"1 void ( * ddcci_data_handler )( struct evdi_ddcci_data ddcci_data , void * user_data ); This notification is sent when an i2c request has been made to the DDC/CI address (0x37). The module will wait for a maximum of DDCCI_TIMEOUT_MS (50ms - The default DDC request timeout) for a response to this request to be passed back via evdi_ddcci_response .","title":"DDC/CI data notification"},{"location":"details/#logging","text":"Client can register their own callback to be used for logging instead of default printf . 1 void evdi_set_logging ( struct evdi_logging evdi_logging ); For more on argument see struct evdi_logging .","title":"Logging"},{"location":"details/#types","text":"","title":"Types"},{"location":"details/#evdi_handle","text":"This is a handle to an opened device node that you get from an evdi_open call, and use in all following API calls to indicate which EVDI device you communicate with.","title":"evdi_handle"},{"location":"details/#evdi_selectable","text":"A typedef denoting a file descriptor you can watch to know when there are events being signalled from the kernel module. Each opened EVDI device handle has its own descriptor to watch. When the descriptor becomes ready to read from, the application should call evdi_handle_events to dispatch notifications to its handlers.","title":"evdi_selectable"},{"location":"details/#evdi_device_status","text":"An enumerated type used while finding the DRM device node that is EVDI. Possible values are AVAILABLE , UNRECOGNIZED and NOT_PRESENT .","title":"evdi_device_status"},{"location":"details/#evdi_rect","text":"A simple structure used by the library to represent a rectangular area of a screen. Top left coordinates of the rectangle are x1 and y1 , bottom right are x2 and y2 .","title":"evdi_rect"},{"location":"details/#evdi_mode","text":"A structure used to describe a video mode that's set for a display. Contains details of resolution set ( width , height ), refresh rate ( refresh_rate ), and details of a pixel format used to encode color value ( bits_per_pixel and pixel_format - which are forwarded from kernel's DRM).","title":"evdi_mode"},{"location":"details/#evdi_buffer","text":"A structure holding details about a buffer. 1 2 3 4 5 6 7 8 9 10 typedef struct { int id ; void * buffer ; int width ; int height ; int stride ; evdi_rect * rects ; int rect_count ; } evdi_buffer ; Buffers have IDs, which can be arbitrarily chosen integer numbers - but typically a simple sequence of numbers starting from 0 is used in client applications. The pointer to the beginning of an already allocated memory block should be assigned to the buffer member of the structure. This memory will be filled by the kernel module when handling requests to grab pixels. width , height and stride are properties of the buffer - the first two indicate what the size of the frame is, and stride is a width stride - tells what is the increment in bytes between data for lines in memory. Stride can be equal to width of a single line multiplied by the number of bytes necessary for encoding color value for one pixel (e.g. 4 for RGB32) if the data for lines are contigous in the memory, but you can use larger value to indicate extra space/padding between them, e.g. oftentimes an additional requirement for the value of stride is it being divisbile by 8; note that those values might be specific to particular hardware/graphic drivers. Please consult documentation of your GPU for details. Last two structure members, rects and rect_counts are updated during grabbing pixels to inform about the number and coordinates of areas that are changed from the last update.","title":"evdi_buffer"},{"location":"details/#evdi_event_context","text":"1 2 3 4 5 6 7 8 9 10 typedef struct { void ( * dpms_handler )( int dpms_mode , void * user_data ); void ( * mode_changed_handler )( evdi_mode mode , void * user_data ); void ( * update_ready_handler )( int buffer_to_be_updated , void * user_data ); void ( * crtc_state_handler )( int state , void * user_data ); void ( * cursor_set_handler )( struct evdi_cursor_set cursor_set , void * user_data ); void ( * cursor_move_handler )( struct evdi_cursor_move cursor_move , void * user_data ); void ( * ddcci_data_handler )( struct evdi_ddcci_data ddcci_data , void * user_data ); void * user_data ; } evdi_event_context ; The evdi_device_context structure is used for holding pointers to handlers for all notifications that the application may receive from the kernel module. The user_data member is a value that the library will use while dispatching the call back. See Events and handlers for more information.","title":"evdi_event_context"},{"location":"details/#evdi_lib_version","text":"1 2 3 4 5 struct evdi_lib_version { int version_major ; int version_minor ; int version_patchlevel ; }; The evdi_lib_version structure contains libevdi version. Version can be used to check compatibility between library and a client application.","title":"evdi_lib_version"},{"location":"details/#evdi_cursor_set","text":"1 2 3 4 5 6 7 8 9 10 11 struct evdi_cursor_set { int32_t hot_x ; int32_t hot_y ; uint32_t width ; uint32_t height ; uint8_t enabled ; uint32_t buffer_length ; uint32_t * buffer ; uint32_t pixel_format ; uint32_t stride ; }; The evdi_cursor_set structure contains cursor state information. hot_x and hot_y define hotspot information. enabled parameter is true when cursor bitmap is available and cursor is visible on virtual display. Parameters width and height define size of the cursor bitmap stored in a buffer memory area of size buffer_length . Warning Event handler or library user has to free buffer memory when it is not using it. Remaining stride and pixel_format describe data organization in the buffer. stride is a size of a single line in a buffer. Usually it is width of the cursor multiplied by bytes per pixel value plus additional extra padding. It ensures proper alignment of subsequent pixel rows. Pixel encoding is described by FourCC code in pixel_format field.","title":"evdi_cursor_set"},{"location":"details/#evdi_cursor_move","text":"1 2 3 4 struct evdi_cursor_move { int32_t x ; int32_t y ; }; The evdi_cursor_move structure contains current cursor position. It is defined as top left corner of the cursor bitmap.","title":"evdi_cursor_move"},{"location":"details/#evdi_ddcci_data","text":"1 2 3 4 5 6 struct evdi_ddcci_data { uint16_t address ; uint16_t flags ; uint32_t buffer_length ; uint8_t * buffer ; }; The evdi_ddcci_data structure contains: address i2c address, will always be 0x37. flags read/write flags. Read = 1, Write = 0. buffer_length the length of the buffer. buffer pointer to the ddc/ci buffer. For both read and write this will be truncated to 64 bytes ( DDCCI_BUFFER_SIZE ). Warning Although the DDC spec advices the maximum buffer length is 32 bytes, we have identified monitors which support bigger buffers.","title":"evdi_ddcci_data"},{"location":"details/#evdi_logging","text":"1 2 3 4 struct evdi_logging { void ( * function )( void * user_data , const char * fmt , ...); void * user_data ; }; Structure contains two fields: function which is a pointer to the actual callback. The fmt and ... are the same as in case of printf . user_data a pointer provided by the client when registering callback Note By setting function to NULL libevdi will switch to default behaviour of using printf .","title":"evdi_logging"},{"location":"quickstart/","text":"Quick Start Typical application EVDI nodes Adding new nodes (pre v1.9.0) Opening EVDI node (pre v1.9.0) Requesting EVDI node (since v1.9.0) Closing EVDI node Connecting and disconnecting Frame buffers Cursor DDC/CI Running loop Events and notifications Types of events Logging Quick Start \u00b6 This section explains how to write a basic client for EVDI. Details of API calls are omitted here for brevity. Typical application \u00b6 Applications using EVDI will typically: find a free EVDI node, or add a new node if none was found; then open it connect to the EVDI node, letting the DRM subsystem know what is the monitor that the application drives allocate memory for, and register buffer(s) that will be used to receive screen updates request and consume updates and other notifications in a loop EVDI nodes \u00b6 EVDI reuses DRM subsystem's cardX nodes for passing messages between the kernel and userspace. In order to distinguish non-EVDI nodes from a node that's created by EVDI kernel module, evdi_check_device function should be used. The library only allows to connect to DRM nodes that are created by EVDI. Attempts to connect to other nodes (e.g. related to a built-in GPU) will fail. Note Using EVDI nodes currently requires administrative rights, so applications must be run with sudo , or by root. Adding new nodes (pre v1.9.0) \u00b6 In order to create a new EVDI cardX node, call evdi_add_device function. A single call adds one additional DRM card node that can later be used to connect to. At the moment, every extra screen that you want to manage needs a separate node. Opening EVDI node (pre v1.9.0) \u00b6 Once an available EVDI node is identified, your application should call evdi_open , passing a number of cardX that you want to open. This returns an evdi_handle that you will use for following API calls, or EVDI_INVALID_HANDLE if opening failed. Requesting EVDI node (since v1.9.0) \u00b6 Adding and opening evdi devices is easier since libevdi v1.9.0. It's sufficient to call evdi_open_attached_to(NULL) in order to add a new evdi node and open it. It is possible to bind evdi devices with usb devices if it is necessary to show such relationship in sysfs. It is done via const char *sysfs_parent_device parameter of evdi_open_attached_to function. USB parent device is described by a string with the following format: usb:[busNum]-[portNum1].[portNum2].[portNum3]... e.g. A evdi_open_attached_to(\"usb:2-2.1\") call will link /sys/bus/usb/devices/2-2.1/evdi.0 to /sys/bus/platform/devices/evdi.0 which is the first available evdi node. Closing EVDI node \u00b6 In order to close the handle, call evdi_close . Connecting and disconnecting \u00b6 Connecting to EVDI tells DRM subsystem that there is a monitor connected, and from this moment the system is aware of an extra display. Connection also lets DRM know what is the EDID of the monitor that a particular EVDI node handles. Think of this as something similar to plugging a monitor with a cable to a port of a graphics card. Similarly, disconnecting indicates that the display is no longer there - like physically pulling cable out from the graphics adapter port. To connect or disconnect, use evdi_connect and evdi_disconnect , respectively. Frame buffers \u00b6 To know what the contents of the screen is, your application will use a block of memory that it can read pixel data from. The library itself does not allocate any memory for buffers - this is to allow more control in the client application. Therefore, before you request screen updates for the screens you're managing, an appropriate amount of memory must be allocated to hold screen data within your application. The application can register as many buffers as you like, and subsequent update requests can refer to any buffer that was previously registered. Allocated memory is made available for EVDI library to use by calling evdi_register_buffer . Symmetrically, evdi_unregister_buffer is used to tell the library not to use the buffer anymore. Cursor \u00b6 Mouse cursor is an important part of the desktop. Because of this, evdi provides special control over it. There are two ways to handle cursor: Automatic cursor compositing on framebuffer(default). Every cursor change causes update_ready event to be raised. In the following grab pixels operation evdi will compose cursor on the user supplied framebuffer. Cursor change notifications. Enabled with evdi_enable_cursor_events function call. In that mode the responsibility for cursor blending is passed to the library client. Instead of update_ready event the cursor_set and cursor_move notifications are sent. DDC/CI \u00b6 As part of creating an EVDI node, the module also creates an i2c adapter. This can be used to pass DDC/CI buffers to and from the connected monitor to adjust brightness and contrast. Data requests to this adapter for DDC/CI (on address 0x37) are passed to userspace as DDC/CI data notifications via ddcci_data_handler and responses are passed back using evdi_ddcci_response . Running loop \u00b6 After registering buffers, the application should start requesting updates for them. This is done using evdi_request_update . You should call it when you intend to consume pixels for the screen. Once the request to update buffer is handled by the kernel module, you can use evdi_grab_pixels to get the data in your app. This also includes finding out which areas of the buffer are in fact modified, compared to a previous update. Events and notifications \u00b6 Due to its design and split of responsibilities between the kernel and userspace code, EVDI's working model is an asynchronous one. Therefore, your application should monitor a file descriptor exposed by evdi_get_event_ready function, and once it becomes ready to read, call evdi_handle_events to dispatch events that are being signalled to the right handlers. The handlers are defined in your application and are shared with the library through a evdi_event_context structure that evdi_handle_events uses for dispatching the call. Types of events \u00b6 The notifications your application can (and should) be handling, are: Update ready notification (sent once a request to update a buffer is handled by kernel) Mode changed notification (sent from DRM after screen mode is changed) DPMS notifications (telling the new power state of a connector) CRTC state change event (exposing DRM CRTC state) Cursor events (send when cursor position or state changes) DDC/CI notification (sent when an i2c request for DDC/CI data is made) You will start receiving first notifications from the kernel module right after connecting to EVDI. Your application should use this information before you ask for screen updates to make sure the buffers are the right size. Logging \u00b6 By default libevdi uses printf to print messages to stdout. Client application can provide its own callback which will be used instead by calling evdi_set_logging . The same function can be used to switch back to default behaviour (by setting callback to NULL );","title":"Quick Start"},{"location":"quickstart/#quick-start","text":"This section explains how to write a basic client for EVDI. Details of API calls are omitted here for brevity.","title":"Quick Start"},{"location":"quickstart/#typical-application","text":"Applications using EVDI will typically: find a free EVDI node, or add a new node if none was found; then open it connect to the EVDI node, letting the DRM subsystem know what is the monitor that the application drives allocate memory for, and register buffer(s) that will be used to receive screen updates request and consume updates and other notifications in a loop","title":"Typical application"},{"location":"quickstart/#evdi-nodes","text":"EVDI reuses DRM subsystem's cardX nodes for passing messages between the kernel and userspace. In order to distinguish non-EVDI nodes from a node that's created by EVDI kernel module, evdi_check_device function should be used. The library only allows to connect to DRM nodes that are created by EVDI. Attempts to connect to other nodes (e.g. related to a built-in GPU) will fail. Note Using EVDI nodes currently requires administrative rights, so applications must be run with sudo , or by root.","title":"EVDI nodes"},{"location":"quickstart/#adding-new-nodes-pre-v190","text":"In order to create a new EVDI cardX node, call evdi_add_device function. A single call adds one additional DRM card node that can later be used to connect to. At the moment, every extra screen that you want to manage needs a separate node.","title":"Adding new nodes (pre v1.9.0)"},{"location":"quickstart/#opening-evdi-node-pre-v190","text":"Once an available EVDI node is identified, your application should call evdi_open , passing a number of cardX that you want to open. This returns an evdi_handle that you will use for following API calls, or EVDI_INVALID_HANDLE if opening failed.","title":"Opening EVDI node (pre v1.9.0)"},{"location":"quickstart/#requesting-evdi-node-since-v190","text":"Adding and opening evdi devices is easier since libevdi v1.9.0. It's sufficient to call evdi_open_attached_to(NULL) in order to add a new evdi node and open it. It is possible to bind evdi devices with usb devices if it is necessary to show such relationship in sysfs. It is done via const char *sysfs_parent_device parameter of evdi_open_attached_to function. USB parent device is described by a string with the following format: usb:[busNum]-[portNum1].[portNum2].[portNum3]... e.g. A evdi_open_attached_to(\"usb:2-2.1\") call will link /sys/bus/usb/devices/2-2.1/evdi.0 to /sys/bus/platform/devices/evdi.0 which is the first available evdi node.","title":"Requesting EVDI node (since v1.9.0)"},{"location":"quickstart/#closing-evdi-node","text":"In order to close the handle, call evdi_close .","title":"Closing EVDI node"},{"location":"quickstart/#connecting-and-disconnecting","text":"Connecting to EVDI tells DRM subsystem that there is a monitor connected, and from this moment the system is aware of an extra display. Connection also lets DRM know what is the EDID of the monitor that a particular EVDI node handles. Think of this as something similar to plugging a monitor with a cable to a port of a graphics card. Similarly, disconnecting indicates that the display is no longer there - like physically pulling cable out from the graphics adapter port. To connect or disconnect, use evdi_connect and evdi_disconnect , respectively.","title":"Connecting and disconnecting"},{"location":"quickstart/#frame-buffers","text":"To know what the contents of the screen is, your application will use a block of memory that it can read pixel data from. The library itself does not allocate any memory for buffers - this is to allow more control in the client application. Therefore, before you request screen updates for the screens you're managing, an appropriate amount of memory must be allocated to hold screen data within your application. The application can register as many buffers as you like, and subsequent update requests can refer to any buffer that was previously registered. Allocated memory is made available for EVDI library to use by calling evdi_register_buffer . Symmetrically, evdi_unregister_buffer is used to tell the library not to use the buffer anymore.","title":"Frame buffers"},{"location":"quickstart/#cursor","text":"Mouse cursor is an important part of the desktop. Because of this, evdi provides special control over it. There are two ways to handle cursor: Automatic cursor compositing on framebuffer(default). Every cursor change causes update_ready event to be raised. In the following grab pixels operation evdi will compose cursor on the user supplied framebuffer. Cursor change notifications. Enabled with evdi_enable_cursor_events function call. In that mode the responsibility for cursor blending is passed to the library client. Instead of update_ready event the cursor_set and cursor_move notifications are sent.","title":"Cursor"},{"location":"quickstart/#ddcci","text":"As part of creating an EVDI node, the module also creates an i2c adapter. This can be used to pass DDC/CI buffers to and from the connected monitor to adjust brightness and contrast. Data requests to this adapter for DDC/CI (on address 0x37) are passed to userspace as DDC/CI data notifications via ddcci_data_handler and responses are passed back using evdi_ddcci_response .","title":"DDC/CI"},{"location":"quickstart/#running-loop","text":"After registering buffers, the application should start requesting updates for them. This is done using evdi_request_update . You should call it when you intend to consume pixels for the screen. Once the request to update buffer is handled by the kernel module, you can use evdi_grab_pixels to get the data in your app. This also includes finding out which areas of the buffer are in fact modified, compared to a previous update.","title":"Running loop"},{"location":"quickstart/#events-and-notifications","text":"Due to its design and split of responsibilities between the kernel and userspace code, EVDI's working model is an asynchronous one. Therefore, your application should monitor a file descriptor exposed by evdi_get_event_ready function, and once it becomes ready to read, call evdi_handle_events to dispatch events that are being signalled to the right handlers. The handlers are defined in your application and are shared with the library through a evdi_event_context structure that evdi_handle_events uses for dispatching the call.","title":"Events and notifications"},{"location":"quickstart/#types-of-events","text":"The notifications your application can (and should) be handling, are: Update ready notification (sent once a request to update a buffer is handled by kernel) Mode changed notification (sent from DRM after screen mode is changed) DPMS notifications (telling the new power state of a connector) CRTC state change event (exposing DRM CRTC state) Cursor events (send when cursor position or state changes) DDC/CI notification (sent when an i2c request for DDC/CI data is made) You will start receiving first notifications from the kernel module right after connecting to EVDI. Your application should use this information before you ask for screen updates to make sure the buffers are the right size.","title":"Types of events"},{"location":"quickstart/#logging","text":"By default libevdi uses printf to print messages to stdout. Client application can provide its own callback which will be used instead by calling evdi_set_logging . The same function can be used to switch back to default behaviour (by setting callback to NULL );","title":"Logging"}]}