<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  
  
  <link rel="shortcut icon" href="../img/favicon.ico">
  <title>Quick Start - EVDI Docs</title>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700" />

  <link rel="stylesheet" href="../css/theme.css" />
  <link rel="stylesheet" href="../css/theme_extra.css" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" />
  
  <script>
    // Current page data
    var mkdocs_page_name = "Quick Start";
    var mkdocs_page_input_path = "quickstart.md";
    var mkdocs_page_url = null;
  </script>
  
  <script src="../js/jquery-2.1.1.min.js" defer></script>
  <script src="../js/modernizr-2.8.3.min.js" defer></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script> 
  
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
        <a href=".." class="icon icon-home"> EVDI Docs</a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="..">Home</a>
                    </li>
                </ul>
                <ul class="current">
                    <li class="toctree-l1 current"><a class="reference internal current" href="./">Quick Start</a>
    <ul class="current">
    </ul>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../details/">Detailed description</a>
                    </li>
                </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="..">EVDI Docs</a>
      </nav>

      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="..">Docs</a> &raquo;</li>
    
      
    
    <li>Quick Start</li>
    <li class="wy-breadcrumbs-aside">
      
    </li>
  </ul>
  
  <hr/>
</div>
          <div role="main">
            <div class="section">
              
                <div class="toc">
<ul>
<li><a href="#quick-start">Quick Start</a></li>
<li><a href="#typical-application">Typical application</a><ul>
<li><a href="#evdi-nodes">EVDI nodes</a><ul>
<li><a href="#adding-new-nodes-pre-v190">Adding new nodes (pre v1.9.0)</a></li>
<li><a href="#opening-evdi-node-pre-v190">Opening EVDI node (pre v1.9.0)</a></li>
<li><a href="#requesting-evdi-node-since-v190">Requesting EVDI node (since v1.9.0)</a></li>
<li><a href="#closing-evdi-node">Closing EVDI node</a></li>
</ul>
</li>
<li><a href="#connecting-and-disconnecting">Connecting and disconnecting</a></li>
<li><a href="#frame-buffers">Frame buffers</a></li>
<li><a href="#cursor">Cursor</a></li>
<li><a href="#ddcci">DDC/CI</a></li>
<li><a href="#running-loop">Running loop</a></li>
<li><a href="#events-and-notifications">Events and notifications</a><ul>
<li><a href="#types-of-events">Types of events</a></li>
</ul>
</li>
<li><a href="#logging">Logging</a></li>
</ul>
</li>
</ul>
</div>
<h1 id="quick-start">Quick Start<a class="headerlink" href="#quick-start" title="Permanent link">&para;</a></h1>
<p>This section explains how to write a basic client for EVDI. Details of API calls are omitted here for brevity.</p>
<h1 id="typical-application">Typical application<a class="headerlink" href="#typical-application" title="Permanent link">&para;</a></h1>
<p>Applications using EVDI will typically:</p>
<ul>
<li>find a free EVDI node, or add a new node if none was found; then open it</li>
<li>connect to the EVDI node, letting the DRM subsystem know what is the monitor that the application drives</li>
<li>allocate memory for, and register buffer(s) that will be used to receive screen updates</li>
<li>request and consume updates and other notifications in a loop</li>
</ul>
<h2 id="evdi-nodes">EVDI nodes<a class="headerlink" href="#evdi-nodes" title="Permanent link">&para;</a></h2>
<p>EVDI reuses DRM subsystem's <code>cardX</code> nodes for passing messages between the kernel and userspace.
In order to distinguish non-EVDI nodes from a node that's created by EVDI kernel module, <code>evdi_check_device</code> function should be used.</p>
<p>The library only allows to connect to DRM nodes that are created by EVDI.
Attempts to connect to other nodes (e.g. related to a built-in GPU) will fail.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Using EVDI nodes currently requires administrative rights, so applications must be run with <code>sudo</code>, or by root.</p>
</div>
<h3 id="adding-new-nodes-pre-v190">Adding new nodes (pre v1.9.0)<a class="headerlink" href="#adding-new-nodes-pre-v190" title="Permanent link">&para;</a></h3>
<p>In order to create a new EVDI <code>cardX</code> node, call <code>evdi_add_device</code> function.
A single call adds one additional DRM card node that can later be used to connect to.</p>
<p>At the moment, every extra screen that you want to manage needs a separate node.</p>
<h3 id="opening-evdi-node-pre-v190">Opening EVDI node (pre v1.9.0)<a class="headerlink" href="#opening-evdi-node-pre-v190" title="Permanent link">&para;</a></h3>
<p>Once an available EVDI node is identified, your application should call <code>evdi_open</code>, passing a number of <code>cardX</code> that you want to open.
This returns an <code>evdi_handle</code> that you will use for following API calls, or <code>EVDI_INVALID_HANDLE</code> if opening failed.</p>
<h3 id="requesting-evdi-node-since-v190">Requesting EVDI node (since v1.9.0)<a class="headerlink" href="#requesting-evdi-node-since-v190" title="Permanent link">&para;</a></h3>
<p>Adding and opening evdi devices is easier since libevdi v1.9.0. It's sufficient to call <code>evdi_open_attached_to(NULL)</code> in order to add a new evdi node and open it.</p>
<p>It is possible to bind evdi devices with usb devices if it is necessary to show such relationship in sysfs.
It is done via <code>const char *sysfs_parent_device</code> parameter of <code>evdi_open_attached_to</code> function.
USB parent device is described by a string with the following format: <code>usb:[busNum]-[portNum1].[portNum2].[portNum3]...</code></p>
<p>e.g.
A <code>evdi_open_attached_to("usb:2-2.1")</code> call will link <code>/sys/bus/usb/devices/2-2.1/evdi.0</code> to
<code>/sys/bus/platform/devices/evdi.0</code> which is the first available evdi node.</p>
<h3 id="closing-evdi-node">Closing EVDI node<a class="headerlink" href="#closing-evdi-node" title="Permanent link">&para;</a></h3>
<p>In order to close the handle, call <code>evdi_close</code>.</p>
<h2 id="connecting-and-disconnecting">Connecting and disconnecting<a class="headerlink" href="#connecting-and-disconnecting" title="Permanent link">&para;</a></h2>
<p>Connecting to EVDI tells DRM subsystem that there is a monitor connected, and from this moment the system is aware of an extra display.
Connection also lets DRM know what is the <a href="https://en.wikipedia.org/wiki/Extended_Display_Identification_Data">EDID</a> of the monitor that a particular EVDI node handles.
Think of this as something similar to plugging a monitor with a cable to a port of a graphics card.</p>
<p>Similarly, disconnecting indicates that the display is no longer there - like physically pulling cable out from the graphics adapter port.</p>
<p>To connect or disconnect, use <code>evdi_connect</code> and <code>evdi_disconnect</code>, respectively.</p>
<h2 id="frame-buffers">Frame buffers<a class="headerlink" href="#frame-buffers" title="Permanent link">&para;</a></h2>
<p>To know what the contents of the screen is, your application will use a block of memory that it can read pixel data from.</p>
<p>The library itself does <em>not</em> allocate any memory for buffers - this is to allow more control in the client application.
Therefore, before you request screen updates for the screens you're managing, an appropriate amount of memory must be allocated to hold screen data within your application.
The application can register as many buffers as you like, and subsequent update requests can refer to any buffer that was previously registered.</p>
<p>Allocated memory is made available for EVDI library to use by calling <code>evdi_register_buffer</code>. Symmetrically, <code>evdi_unregister_buffer</code> is used to tell the library not to use the buffer anymore.</p>
<h2 id="cursor">Cursor<a class="headerlink" href="#cursor" title="Permanent link">&para;</a></h2>
<p>Mouse cursor is an important part of the desktop. Because of this, evdi provides special control over it.</p>
<p>There are two ways to handle cursor:</p>
<ul>
<li>Automatic cursor compositing on framebuffer(default). Every cursor change causes <code>update_ready</code> event to be raised. In the following grab pixels operation evdi will compose cursor
on the user supplied framebuffer.</li>
<li>Cursor change notifications. Enabled with <code>evdi_enable_cursor_events</code> function call.
In that mode the responsibility for cursor blending is passed to the library client. Instead of <code>update_ready</code> event the <code>cursor_set</code> and <code>cursor_move</code> notifications are sent.</li>
</ul>
<h2 id="ddcci">DDC/CI<a class="headerlink" href="#ddcci" title="Permanent link">&para;</a></h2>
<p>As part of creating an EVDI node, the module also creates an i2c adapter. This can be used to pass DDC/CI buffers to and from the connected monitor to adjust brightness and contrast.
Data requests to this adapter for DDC/CI (on address 0x37) are passed to userspace as DDC/CI data notifications via <code>ddcci_data_handler</code> and responses are passed back using <code>evdi_ddcci_response</code>.</p>
<h2 id="running-loop">Running loop<a class="headerlink" href="#running-loop" title="Permanent link">&para;</a></h2>
<p>After registering buffers, the application should start requesting updates for them. This is done using <code>evdi_request_update</code>.
You should call it when you intend to consume pixels for the screen.</p>
<p>Once the request to update buffer is handled by the kernel module, you can use <code>evdi_grab_pixels</code> to get the data in your app.
This also includes finding out which areas of the buffer are in fact modified, compared to a previous update.</p>
<h2 id="events-and-notifications">Events and notifications<a class="headerlink" href="#events-and-notifications" title="Permanent link">&para;</a></h2>
<p>Due to its design and split of responsibilities between the kernel and userspace code, EVDI's working model is an asynchronous one.
Therefore, your application should monitor a file descriptor exposed by <code>evdi_get_event_ready</code> function, and once it becomes ready to read,
call <code>evdi_handle_events</code> to dispatch events that are being signalled to the right handlers.</p>
<p>The handlers are defined in your application and are shared with the library through a <code>evdi_event_context</code> structure that <code>evdi_handle_events</code> uses for dispatching the call.</p>
<h3 id="types-of-events">Types of events<a class="headerlink" href="#types-of-events" title="Permanent link">&para;</a></h3>
<p>The notifications your application can (and should) be handling, are:</p>
<ul>
<li>Update ready notification (sent once a request to update a buffer is handled by kernel)</li>
<li>Mode changed notification (sent from DRM after screen mode is changed)</li>
<li>DPMS notifications (telling the new power state of a connector)</li>
<li>CRTC state change event (exposing DRM CRTC state)</li>
<li>Cursor events (send when cursor position or state changes)</li>
<li>DDC/CI notification (sent when an i2c request for DDC/CI data is made)</li>
</ul>
<p>You will start receiving first notifications from the kernel module right after connecting to EVDI.
Your application should use this information before you ask for screen updates to make sure the buffers are the right size.</p>
<h2 id="logging">Logging<a class="headerlink" href="#logging" title="Permanent link">&para;</a></h2>
<p>By default libevdi uses <code>printf</code> to print messages to stdout. Client application can provide its own callback which will be used instead by calling <code>evdi_set_logging</code>.
The same function can be used to switch back to default behaviour (by setting callback to <code>NULL</code>);</p>
              
            </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../details/" class="btn btn-neutral float-right" title="Detailed description">Next <span class="icon icon-circle-arrow-right"></span></a>
      
      
        <a href=".." class="btn btn-neutral" title="Home"><span class="icon icon-circle-arrow-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
    
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
      
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="versions">
    <span class="rst-current-version" data-toggle="rst-current-version">
      
      
        <span><a href=".." style="color: #fcfcfc;">&laquo; Previous</a></span>
      
      
        <span style="margin-left: 15px"><a href="../details/" style="color: #fcfcfc">Next &raquo;</a></span>
      
    </span>
</div>
    <script>var base_url = '..';</script>
    <script src="../js/theme.js" defer></script>
      <script src="../search/main.js" defer></script>
    <script defer>
        window.onload = function () {
            SphinxRtdTheme.Navigation.enable(true);
        };
    </script>

</body>
</html>
